# -*- coding: utf-8 -*-
import datetime
from datetime import date
import pandas as pd
from dateutil.relativedelta import relativedelta

"""

TITLE: Valuing Interest Rate Swaps Using OIS Discounting (Part A)

SOURCE: Boston University School of Management Research Paper Series (No.2012-­‐11)
        Valuing Interest Rate Swaps Using OIS Discounting By Donald J. Smith
        Electronic copy available at: http://ssrn.com/abstract=2036979


OBJECTIVE: Compare Swap Market Value using both LIBOR discounting and OIS discounting
           and discuss the python implementation of the two methodologies using the
           above article as the main source.  In this part of the series we only discussed
           swap valuation using LIBOR discounting.  Subsequently, we will discuss the OIS
           discounting methodology.  To read about the relative merit of OIS discounting over
           LIBOR discounting refer to the above article or other sources.
           
NB: We will expand on our discussion at a later time and refine the program.  See you next time!!
           

IMPLEMENTATION (PROTOTYPE).

Consider a 2-year, USD 100,000,000.00 (100 million USD) notional principal,
5.26% fixed versus 3-month LIBOR, quarterly settlement swap at a time when the 
otherwise comparable at-market fixed rate is 3.40%.  

Time        Description         Rate
3-month     LIBOR               0.50%
6-month     LIBOR               1.00%
9-month     LIBOR               1.60%
12-month    LIBOR               2.10%
15-month    SFR                 2.44%
18-month    SFR                 2.76%
21-month    SFR                 3.08%
24-month    SFR                 3.40%

Valuation Date is March 15th 2010. 

Typically, swap fixed rates start at a tenor of two years. This creates the need to 
interpolate for the span between year one and year two. However, this example assumes
that the swap fixed for 15th, 18th and 21st month have already been boostrapped.

Date Count Convention -> Actual/360

"""
#Declare the rate as a list
rate = [0.50,1.00,1.60,2.10,2.44,2.76,3.08,3.40] #in percentage 

#Generate a list of cashflow payment dates
maturities = []
for x in range(1,9):
    maturities.append(datetime.date(2010, 3, 15)+relativedelta(months=3*x))
    
#The function below can be used to generate the value of the fixed leg of the
#swap using a flat term structure. The value of a bond is calculated using
#discount factors generated from LIBOR and SFR.  This is just for illustration 
#only and the other approach is documented below.

#The value of the fixed cashflow payments excluding the notional principal can
#be calculated by deducting the principal value from the amount generated by 
#this function.

def flatTermStructureValuation(principal, coupon_rate, paymentFrequency, mkt_rate, years):
    coupon_payment = principal * (coupon_rate/100.0)/paymentFrequency
    n = paymentFrequency * years
    #declare intermediate variables
    y = mkt_rate/100.0
    total = 0.0
    coupon2 = 0.0
    dPrin = 0.0
    subtotal = 0.0
    total = 0.0
    for x in range(1,n+1,1):
        coupon2 = coupon_payment/(1+y/paymentFrequency)**x
        total += coupon2
        subtotal = dPrin + coupon2
        if x == n:
            total += principal/(1+y/paymentFrequency)**x
            dPrin = principal/(1+y/paymentFrequency)**x
            subtotal = dPrin + coupon2
    return subtotal
        
#Example call - no commas or Dollar sign in numbers (Principal = 2000, Coupon = 4.00, Payment Frequency = 1, Yield/Mkt Rate = 3.00, Years to Maturity = 12)  n = 1 to 4
round(flatTermStructureValuation(500, 4.00, 2, 3.5, 10),2)

#GENERATING THE DISCOUNT FACTORS FROM LIBOR

#Formula -> Dfn = 1/(1 + LIBORn * Sum of the fraction of the year from the ith period to the nth period using the specified date convention) 
#See the article for the actual formula notation. 


val_date = datetime.date(2010, 3, 15)
rate = [0.50,1.00,1.60,2.10,2.44,2.76,3.08,3.40]
numberOfDays=0
result=0.0
dayCountBase = 360
LIBOR = []


def discountLIBOR():
    for x in range(4):
        numberOfDays = (maturities[x] - val_date).days
        result = 1/(1+ (rate[x]/100.0 * numberOfDays/dayCountBase))
        LIBOR.append(result)
        result=0.0
    return LIBOR



helper = 0.0
SFRStartingIndex = 4
#LIBOR = discountLIBOR()
ans2=0.0
SFRRate = rate[4:]

def discountSFRhelper(LIBORlist,n):
    
    final = 0.0
    ans = 0.0
    #n = n - 1
    for x in range(n):
        if x == 0:
            numberOfDays = (maturities[x] - val_date).days
            ans = numberOfDays/360.0 * LIBORlist[x]
            final = final + ans
            
        else:
            numberOfDays = (maturities[x] - maturities[x-1]).days
            ans = numberOfDays/360.0 * LIBORlist[x]
            final = final + ans 
    
            
    return final


#LIBOR for 5th period
final = 0.0
ans = 0.0
LIBOR = discountLIBOR()

numberOfDays = (maturities[4] - maturities[4-1]).days
ans = (1 - SFRRate[4-4]/100.0 * discountSFRhelper(LIBOR,4))
final=ans/(1 + SFRRate[4-4]/100.0 * numberOfDays/360.0)
LIBOR.append(final)

#LIBOR for 6th period
final = 0.0
ans = 0.0
#LIBOR = discountLIBOR()

numberOfDays = (maturities[5] - maturities[5-1]).days
ans = (1 - SFRRate[5-4]/100.0 * discountSFRhelper(LIBOR,5))
final=ans/(1 + SFRRate[5-4]/100.0 * numberOfDays/360.0)
LIBOR.append(final)
   

#LIBOR for 7th period
final = 0.0
ans = 0.0
#LIBOR = discountLIBOR()

numberOfDays = (maturities[6] - maturities[6-1]).days
ans = (1 - SFRRate[6-4]/100.0 * discountSFRhelper(LIBOR,6))
final=ans/(1 + SFRRate[6-4]/100.0 * numberOfDays/360.0)
LIBOR.append(final)

#LIBOR for 8th period
final = 0.0
ans = 0.0
#LIBOR = discountLIBOR()

numberOfDays = (maturities[7] - maturities[7-1]).days
ans = (1 - SFRRate[7-4]/100.0 * discountSFRhelper(LIBOR,7))
final=ans/(1 + SFRRate[7-4]/100.0 * numberOfDays/360.0)
LIBOR.append(final)


#IMPLIED FORWARD RATE FROM DISCOUNT FACTORS
fRate = []
result = 0.0
for x in range(0,8,1):
    if x == 0:
        fRate.append(rate[0]/100)
    else:
        numberOfDays = (maturities[x] - maturities[x-1]).days
        result = ((LIBOR[x-1]/LIBOR[x]) - 1) * (1/(numberOfDays/360.0))
        fRate.append(result)

#TO DISPLAY THE RATE TABLES - Original LIBOR/SFR, DISC_LIBOR and IMPLIED FORWARD RATE
print ""
rateTable = pd.DataFrame.from_items([('Period', range(1,9,1)),('Rate', rate), ('LIBOR_Disc', LIBOR),('Imp_For_Rate', fRate)])
print(rateTable.to_string())
        
"""
   Period  Rate  LIBOR_Disc  Imp_For_Rate
0       1  0.50    0.998724      0.005000
1       2  1.00    0.994915      0.014981
2       3  1.60    0.987925      0.027989
3       4  2.10    0.979152      0.035840
4       5  2.44    0.969457      0.039132
5       6  2.76    0.958690      0.043949
6       7  3.08    0.946531      0.050818
7       8  3.40    0.932957      0.057556
"""

#MARKET VALUE OF FIXED RATE NOTE/LEG
result = 0.0
ans = 0.0
for x in range(0,8,1):
    if x == 0:
        numberOfDays = (maturities[x] - val_date).days
        ans = ans + numberOfDays/360.0 * LIBOR[x]
    else:
        numberOfDays = (maturities[x] - maturities[x-1]).days
        ans = ans + numberOfDays/360.0 * LIBOR[x]
 
    result =  ans *100000000 * 0.0526 + 100000000 * LIBOR[-1]

#MV Fixed Leg is: 103667623.63209939
print ""
print ("Market Value of Fixed Leg: (MV_Fixed) = ") + str(result)

#MARKET VALUE OF FLOATING RATE NOTE/LEG
#The market value of the floating rate is is assumed to reset to par
#at payment periods but can be recalculated as follow:
result2 = 0.0
ans2 = 0.0
for x in range(0,8,1):
    if x == 0:
        numberOfDays = (maturities[x] - val_date).days
        ans2 =  ans2 + LIBOR[x] * fRate[x] * numberOfDays/360.0
    else:
        numberOfDays = (maturities[x] - maturities[x-1]).days
        ans2 =  ans2 + LIBOR[x] * fRate[x] * numberOfDays/360.0

        
    result2 =    100000000 * LIBOR[-1] + ans2 * 100000000
#MV Floating Leg is: 100000000.00000001
print ""
print ("Market Value of Floating Leg: (MV_FRN) = ") + str(result2)
    

#MARKET VALUE OF SWAP = MKTRATE FIXED - MKTRATE FLOATING
MV = round(result - result2)  #3667624
print ""
print ("Market Value of Swap: (MV_Fixed _ MV_FRN) = ") + str(MV)
#FixedLeg - FloatingLeg = 103667623.63209939 - 100000000.00000001
#MV per article = 3662844
#Difference between python module and article = 4780 #Deemed Immaterial/Due to rounding differences
