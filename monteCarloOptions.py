# -*- coding: utf-8 -*-
"""
TOPIC: European option pricing using Monte Carlo Simulation

SOURCE: Advanced Quantitative Finance with C++ By Alonso PeÃ±a, Ph.D. (Chapter Four)

DISCUSSION: Refer to the book for detailed discussion. This is just a conversion of the C++
code in the book to Python to determine the relative strength of C++ versus Python. C++ is faster than
Python but Python can be made to run faster using libraries like scipy and numpy but then C++ is still
faster.  The random number generators in computers are not really random and you will only get the same 
result if you set a seed for your random number generator.  In fact, using the same information and programming
language on different computers and compilers will give you different answers.  Based on my test the default behavior
of random number generator in C++ and python are totally different.  In python, unless you set a seed, you get different
result each time you run your Monte Carlo simulation but in C++ the default behavior is that you get the same result
for each run of Monte Carlo.  In order to get different results in c++, you have to set a seed using your computer time.  
The question thus becomes what is a reasonable seed because some seeds will give you a totally different result than the 
one you get using the blacksholes formula while others will be close to it. C++ does not seem to have that problem because
of the default behavior which gives you same random numbers unless you set a set which gives you the illusion that the 
solution is consistent.

Anyways, in order to generate normal random numbers from the uniform random numbers generated by the computer, the book 
code used Box Muller algorithm, which I converted to python (see below) but my implementation is slow so I use scipy 
normal random number generator to generate random numbers with gaussion distribution (after a bit of googling of course). 
Using scipy makes it much faster but not as fast as C++ but very very close (I guess there are libraries for C++ as well). 
See you next  time when we will prolly continue our discussions on yield curves. Enjoy the World Cup if you like soccer 
of course!
"""


import random
import math
import numpy as np
from decimal import Decimal
import scipy



def sampleBoxMuller():
    x = 0.0
    y = 0.0
    xysquare = 1000
    
    while (xysquare >= 1.0):
        x = 2.0*random.random() - 1.0
        y = 2.0*random.random() - 1.0
        xysquare = x**2 + y**2
        d = Decimal(xysquare)
        x = Decimal(x)
        
    return float(x*np.sqrt(-2 *d.ln()/d))

#T = maturity, K = strike, s0=spot price, sigma=volatility, r=interest rate, N = number of steps, M=number of simulations
#Type = Put or Call


def optionCalculator(T, K, s0, sigma, r, N, M, Type):
    
    scipy.random.seed(123456)
    #random.seed(2000)
    premium = 0.0
    dt = T/N
    sumpayoff= scipy.zeros([M], dtype=float)
    sumpayoff2= scipy.zeros([M], dtype=float)
    for x in range(0,M):
        S=s0    
        for y in range(0,N):
            epsilon = scipy.random.normal()  #We could have used Box-Muller here but makes the program slow
            S*=math.exp((r-0.5*sigma*sigma)*dt+sigma*np.sqrt(dt)*epsilon)  
            sumpayoff[x] = max(S-K,0.0)
            sumpayoff2[x] = max(K-S,0.0)
    if Type == "call":
        premium = math.exp(-r*T) * np.mean(sumpayoff)  #for call
    elif Type == "put":
        premium = math.exp(-r*T) * np.mean(sumpayoff2)  #for put
    return premium

#Sample Call
#optionCalculator(1.0,100.0,100.0,0.1,0.05,500,5000,"call")

            
        
